---
title: "Daily Predictors for Diabetes Management"
author: "Tim Vigers & Laura Pyle"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r setup, include=FALSE}
library(Hmisc)
library(arsenal)
library(skimr)
library(knitr)
library(tidyverse)
library(lubridate)
library(redcapAPI)
library(nlme)
library(glmmLasso)
library(parallel)
library(caret)
library(glmnet)
library(UpSetR)
knitr::opts_chunk$set(echo = F,cache = F)
home_dir = ifelse(.Platform$OS.type != "unix","Z:/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/BDC/Projects",
                  "~/UCD/PEDS/RI Biostatistics Core/Shared/Shared Projects/Laura/BDC/Projects")
knitr::opts_knit$set(root.dir = home_dir)
set.seed(1017)
```

```{r clean data}
source("~/GitHub/BDC-Code/Laurel Messer/Daily Predictors/clean_data.r")
# Combine race columns
race_cols = paste0("pt_race___",1:6)
races = c("White","Black or African American","American Indian or Alaskan Native",
          "Asian","Native Hawaiian or Pacific Islander","Other")
data$race = apply(data[,race_cols], 1, function(r){
  paste0(races[which(r == 1)],collapse = ", ")
})
# Calculate age and duration
data$age = as.numeric(ymd(data$pt_visit_date) - ymd(data$pt_dob))/365.25
data$duration = as.numeric(ymd(data$pt_visit_date) - ymd(data$dxdate))/365.25
# ID as factor for glmmLasso
data$record_id = as.factor(data$record_id)
# Correlation between engagement survey items and subscores and:
#   Number of insulin boluses
#   Average glucose level
#   Percent time glucose levels 70-180 mg/dl (“Time-in-Range”, TIR)
#   Goal Survey Scores
morning_items = colnames(data)[grep("esq\\d+$",colnames(data))]
evening_items = colnames(data)[grep("esq\\d+_eve$",colnames(data))]
# Outcomes
goal_survey = c("n_highalerts","dm_caretime","dm_thinktime","gsq1","gsq2","gsq3")
outcomes = c("boluses","smg","tir",goal_survey)
# ID Variables
id_vars = c("record_id","redcap_event_name","date")
# Combine date columns
data$es_date = as.Date.character(lubridate::ymd_hm(data$es_datetimecapture))
data$es_date_eve = as.Date.character(lubridate::ymd_hm(data$es_datetimecapture_eve))
data = data %>% unite(date,dmi_date,es_date,es_date_eve,remove = F,na.rm = T)
data$date = sapply(strsplit(data$date,"_"),function(x){
  ifelse(length(x)==0,NA,
         unique(strsplit(x,"_")[[1]]))
})
# Fill outcome in by date
data = data %>% group_by(record_id,date) %>%
  fill(all_of(outcomes),.direction = "downup") %>%
  ungroup()
```

# Participant Characteristics

```{r results = 'asis'}
# Get first row for each person
demographics = data %>% group_by(record_id) %>% filter(row_number() == 1)
# Table 
t1 = tableby(~ age + duration + pt_a1c + pt_baseline1.factor + pt_baseline5.factor + 
               pt_gender.factor + race + pt_eth.factor + p1_hedu.factor + 
               p2_hedu.factor,demographics)
# Labels
new_labels = list(age = "Age", duration = "Diabetes Duration", pt_a1c = "Baseline HbA1c",
                  pt_baseline1.factor = "Pump Hx",pt_baseline5.factor = "CGM Hx",
                  pt_gender.factor = "Gender", race = "Race", pt_eth.factor = "Ethnicity", 
                  p1_hedu.factor = "Parent 1 Education", p2_hedu.factor = "Parent 2 Education")
summary(t1,labelTranslations = new_labels)
```

# Regularization (LASSO) Results

```{r}
# Optimal lambda function = needs id variables, one outcome, and predictors (nothing else)
lambda_cv = function(df,outcome_name,fam = "gaussian",n_lambda = 200,folds = 5,
                     core_ratio = 0.75,num_coef_higher = 10){
  # Convert to dataframe since these functions can't handle tibbles
  df = data.frame(df)
  # Make model formula
  pred = colnames(df)[which(!colnames(df) %in% c(outcome_name,id_vars))]
  form = as.formula(paste(outcome_name,"~",paste(pred,collapse = "+")))
  # Find lambda starting values
  starts = seq(0,5000,by = 100)
  lambda_start = lapply(starts, function(l){
    mod <- try(suppressWarnings(glmmLasso(form, rnd = list(record_id=~1),
                                          family = fam,
                                          data = df,lambda=l)),
               silent = T)
    num_coefs = ifelse(class(mod)!="try-error",sum(coef(mod) != 0),NA)
  })
  lambda_start = data.frame("starts" = starts,"coefs" = unlist(lambda_start))
  max_lambda = lambda_start$starts[min(which(lambda_start[,2] <= num_coef_higher))]
  min_lambda = lambda_start$starts[max(which(lambda_start[,2] == length(pred)))]
  lambdas = seq(min_lambda,max_lambda,length.out = n_lambda)
  # K-fold cross validation
  k = folds
  # Try lots of different lambdas
  cl <- makeCluster(detectCores()*core_ratio, type='PSOCK')
  clusterExport(cl,list('groupKFold','glmmLasso','R2','RMSE','MAE',
                        'outcome_name','form','lambdas','df','k','fam'),
                envir=environment())
  metrics = parLapply(cl,lambdas,function(l){
    # Cross validate
    sample <- groupKFold(df$record_id,k = k)
    cv = lapply(sample, function(s){
      # Training from group K
      train  <- df[s, ]
      # Test set
      test <- df[-s, ]
      # Fit - fairly different model results with REML vs. EM, but REML is really slow.
      mod <- try(suppressWarnings(glmmLasso(form, rnd = list(record_id=~1),
                                            family = fam,
                                            data = train,lambda=l)),
                 silent = T)
      if(class(mod)!="try-error"){
        # Model performance
        predicted <- predict(mod, test)
        data.frame(R2 = R2(predicted, test[,outcome_name]),
                   RMSE = RMSE(predicted, test[,outcome_name]),
                   MAE = MAE(predicted, test[,outcome_name]))
      } else {
        data.frame(R2 = NA,
                   RMSE = NA,
                   MAE = NA)
      }
    })
    cv = do.call(rbind,cv)
    # Fit again to get final number of coefficients
    mod <- try(suppressWarnings(glmmLasso(form, rnd = list(record_id=~1),
                                          family = fam,
                                          data = df,lambda=l)),
               silent = T)
    num_coefs = ifelse(class(mod)!="try-error",sum(coef(mod) != 0),NA)
    return(c(l,colMeans(cv,na.rm = T),num_coefs))
  })
  stopCluster(cl)
  metrics = data.frame(do.call(rbind,metrics))
  colnames(metrics)[1] = "lambda"
  colnames(metrics)[5] = "num_coefs"
  return(metrics)
}
# Find lambda values where the performance is within 1 SD of the minimum and number of 
# coefficients is between user-specified bounds. Of these, pick the lambda with 
# the minimum error.
best_lambdas = function(perf_metrics = lambda_perf,metric = "RMSE",
                        num_coef_lower = 1,num_coef_higher = 10){
  m = min(perf_metrics[,metric],na.rm = T)
  s = sd(perf_metrics[,metric],na.rm = T)
  sd1 = which(perf_metrics[,metric] >= m - s & perf_metrics[,metric] >= m + s &
                perf_metrics[,"num_coefs"] <= num_coef_higher & 
                perf_metrics[,"num_coefs"] >= num_coef_lower)
  final = sd1[which.min(perf_metrics[sd1,metric])]
  return(perf_metrics$lambda[final])
}
```

## Morning survey

### Number of boluses

```{r}
fam = poisson(link = "log")
# Get morning variables
bolus_morning = data[,c(id_vars,morning_items,"boluses")]
bolus_morning = bolus_morning[complete.cases(bolus_morning),]
# CV for lambda values
lambda_perf = lambda_cv(df = bolus_morning,outcome_name = "boluses",fam = fam)
best = best_lambdas(lambda_perf,"RMSE",num_coef_lower = 5,num_coef_higher = 10)
# Fit model
form = as.formula(paste0("boluses~",paste0(morning_items,collapse = "+")))
bolus_morning_mod = suppressWarnings(
  glmmLasso(form, rnd = list(record_id=~1),family = fam,
            data = bolus_morning,lambda=best)
)
# Get coefficients
bolus_morning_coefs = names(bolus_morning_mod$coefficients)[
  which(bolus_morning_mod$coefficients != 0 & 
          names(bolus_morning_mod$coefficients) != "(Intercept)")]
```

### SMG

```{r}
fam = gaussian()
# Get morning variables
smg_morning = data[,c(id_vars,morning_items,"smg")]
smg_morning = smg_morning[complete.cases(smg_morning),]
# CV for lambda values
lambda_perf = lambda_cv(df = smg_morning,outcome_name = "smg",fam = fam)
best = best_lambdas(lambda_perf,"RMSE",num_coef_lower = 5,num_coef_higher = 10)
# Fit model
form = as.formula(paste0("smg~",paste0(morning_items,collapse = "+")))
smg_morning_mod = suppressWarnings(
  glmmLasso(form, rnd = list(record_id=~1),family = fam,
            data = smg_morning,lambda=best)
)
# Get coefficients
smg_morning_coefs = names(smg_morning_mod$coefficients)[
  which(smg_morning_mod$coefficients != 0 & 
          names(smg_morning_mod$coefficients) != "(Intercept)")]
```

### TIR

```{r}
fam = gaussian()
# Get morning variables
tir_morning = data[,c(id_vars,morning_items,"tir")]
tir_morning = tir_morning[complete.cases(tir_morning),]
# CV for lambda values
lambda_perf = lambda_cv(df = tir_morning,outcome_name = "tir",fam = fam)
best = best_lambdas(lambda_perf,"RMSE",num_coef_lower = 5,num_coef_higher = 10)
# Fit model
form = as.formula(paste0("tir~",paste0(morning_items,collapse = "+")))
tir_morning_mod = suppressWarnings(
  glmmLasso(form, rnd = list(record_id=~1),family = fam,
            data = tir_morning,lambda=best)
)
# Get coefficients
tir_morning_coefs = names(tir_morning_mod$coefficients)[
  which(tir_morning_mod$coefficients != 0 & 
          names(tir_morning_mod$coefficients) != "(Intercept)")]
```

### Upset plot

```{r}
# Format output
selected = do.call(rbind,list(
  morning_items %in% bolus_morning_coefs,
  morning_items %in% smg_morning_coefs,
  morning_items %in% tir_morning_coefs
))
colnames(selected) = morning_items
selected = data.frame(apply(selected,2,as.numeric))
# Plot
upset(selected, order.by = "freq")
```

## Evening survey

### Number of boluses

```{r}
fam = poisson(link = "log")
# Get evening variables
bolus_evening = data[,c(id_vars,evening_items,"boluses")]
bolus_evening = bolus_evening[complete.cases(bolus_evening),]
# CV for lambda values
lambda_perf = lambda_cv(df = bolus_evening,outcome_name = "boluses",fam = fam)
best = best_lambdas(lambda_perf,"RMSE",num_coef_lower = 5,num_coef_higher = 10)
# Fit model
form = as.formula(paste0("boluses~",paste0(evening_items,collapse = "+")))
bolus_evening_mod = suppressWarnings(
  glmmLasso(form, rnd = list(record_id=~1),family = fam,
            data = bolus_evening,lambda=best)
)
# Get coefficients
bolus_evening_coefs = names(bolus_evening_mod$coefficients)[
  which(bolus_evening_mod$coefficients != 0 & 
          names(bolus_evening_mod$coefficients) != "(Intercept)")]
```

### SMG

```{r}
fam = gaussian()
# Get evening variables
smg_evening = data[,c(id_vars,evening_items,"smg")]
smg_evening = smg_evening[complete.cases(smg_evening),]
# CV for lambda values
lambda_perf = lambda_cv(df = smg_evening,outcome_name = "smg",fam = fam)
best = best_lambdas(lambda_perf,"RMSE",num_coef_lower = 5,num_coef_higher = 10)
# Fit model
form = as.formula(paste0("smg~",paste0(evening_items,collapse = "+")))
smg_evening_mod = suppressWarnings(
  glmmLasso(form, rnd = list(record_id=~1),family = fam,
            data = smg_evening,lambda=best)
)
# Get coefficients
smg_evening_coefs = names(smg_evening_mod$coefficients)[
  which(smg_evening_mod$coefficients != 0 & 
          names(smg_evening_mod$coefficients) != "(Intercept)")]
```

### TIR

```{r}
fam = gaussian()
# Get evening variables
tir_evening = data[,c(id_vars,evening_items,"tir")]
tir_evening = tir_evening[complete.cases(tir_evening),]
# CV for lambda values
lambda_perf = lambda_cv(df = tir_evening,outcome_name = "tir",fam = fam)
best = best_lambdas(lambda_perf,"RMSE",num_coef_lower = 5,num_coef_higher = 10)
# Fit model
form = as.formula(paste0("tir~",paste0(evening_items,collapse = "+")))
tir_evening_mod = suppressWarnings(
  glmmLasso(form, rnd = list(record_id=~1),family = fam,
            data = tir_evening,lambda=best)
)
# Get coefficients
tir_evening_coefs = names(tir_evening_mod$coefficients)[
  which(tir_evening_mod$coefficients != 0 & 
          names(tir_evening_mod$coefficients) != "(Intercept)")]
```

### Upset plot

```{r}
# Format output
selected = do.call(rbind,list(
  evening_items %in% bolus_evening_coefs,
  evening_items %in% smg_evening_coefs,
  evening_items %in% tir_evening_coefs
))
colnames(selected) = evening_items
selected = data.frame(apply(selected,2,as.numeric))
# Plot
upset(selected, order.by = "freq")
```



# Questions for Laurel and Emily

1. How should we combine levels of race and parent education? White vs. non-white? Above a bachelor's degree vs. bachelor's and below?
